[
    {
        "label": "os,",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os.",
        "description": "os.",
        "detail": "os.",
        "documentation": {}
    },
    {
        "label": "datetime",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "datetime",
        "description": "datetime",
        "detail": "datetime",
        "documentation": {}
    },
    {
        "label": "operator",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "operator",
        "description": "operator",
        "detail": "operator",
        "documentation": {}
    },
    {
        "label": "subprocess",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "subprocess",
        "description": "subprocess",
        "detail": "subprocess",
        "documentation": {}
    },
    {
        "label": "tempfile",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tempfile",
        "description": "tempfile",
        "detail": "tempfile",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "unittest",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "unittest",
        "description": "unittest",
        "detail": "unittest",
        "documentation": {}
    },
    {
        "label": "warnings",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "warnings",
        "description": "warnings",
        "detail": "warnings",
        "documentation": {}
    },
    {
        "label": "pythoncom",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pythoncom",
        "description": "pythoncom",
        "detail": "pythoncom",
        "documentation": {}
    },
    {
        "label": "win32api",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32api",
        "description": "win32api",
        "detail": "win32api",
        "documentation": {}
    },
    {
        "label": "win32con",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32con",
        "description": "win32con",
        "detail": "win32con",
        "documentation": {}
    },
    {
        "label": "win32file",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "win32file",
        "description": "win32file",
        "detail": "win32file",
        "documentation": {}
    },
    {
        "label": "wmi",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "wmi",
        "description": "wmi",
        "detail": "wmi",
        "documentation": {}
    },
    {
        "label": "escape",
        "importPath": "cgi",
        "description": "cgi",
        "isExtraImport": true,
        "detail": "cgi",
        "documentation": {}
    },
    {
        "label": "make_server",
        "importPath": "wsgiref.simple_server",
        "description": "wsgiref.simple_server",
        "isExtraImport": true,
        "detail": "wsgiref.simple_server",
        "documentation": {}
    },
    {
        "label": "request_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "application_uri",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "shift_path_info",
        "importPath": "wsgiref.util",
        "description": "wsgiref.util",
        "isExtraImport": true,
        "detail": "wsgiref.util",
        "documentation": {}
    },
    {
        "label": "variant_validate",
        "importPath": "src.utils",
        "description": "src.utils",
        "isExtraImport": true,
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "invalid_variant_handler",
        "importPath": "src.utils",
        "description": "src.utils",
        "isExtraImport": true,
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "app_cli",
        "importPath": "src.cli",
        "description": "src.cli",
        "isExtraImport": true,
        "detail": "src.cli",
        "documentation": {}
    },
    {
        "label": "app_cli",
        "importPath": "src.cli",
        "description": "src.cli",
        "isExtraImport": true,
        "detail": "src.cli",
        "documentation": {}
    },
    {
        "label": "app_cli",
        "importPath": "src.cli",
        "description": "src.cli",
        "isExtraImport": true,
        "detail": "src.cli",
        "documentation": {}
    },
    {
        "label": "app_cli",
        "importPath": "src.cli",
        "description": "src.cli",
        "isExtraImport": true,
        "detail": "src.cli",
        "documentation": {}
    },
    {
        "label": "check_internet_connection",
        "importPath": "src.funcs",
        "description": "src.funcs",
        "isExtraImport": true,
        "detail": "src.funcs",
        "documentation": {}
    },
    {
        "label": "check_installed_antivirus",
        "importPath": "src.funcs",
        "description": "src.funcs",
        "isExtraImport": true,
        "detail": "src.funcs",
        "documentation": {}
    },
    {
        "label": "check_installed_firewall",
        "importPath": "src.funcs",
        "description": "src.funcs",
        "isExtraImport": true,
        "detail": "src.funcs",
        "documentation": {}
    },
    {
        "label": "socket",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "socket",
        "description": "socket",
        "detail": "socket",
        "documentation": {}
    },
    {
        "label": "psutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "psutil",
        "description": "psutil",
        "detail": "psutil",
        "documentation": {}
    },
    {
        "label": "shutil",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "shutil",
        "description": "shutil",
        "detail": "shutil",
        "documentation": {}
    },
    {
        "label": "platform",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "platform",
        "description": "platform",
        "detail": "platform",
        "documentation": {}
    },
    {
        "label": "GOOGLE_SERVER_ADDRESS",
        "importPath": "src.const",
        "description": "src.const",
        "isExtraImport": true,
        "detail": "src.const",
        "documentation": {}
    },
    {
        "label": "PORT",
        "importPath": "src.const",
        "description": "src.const",
        "isExtraImport": true,
        "detail": "src.const",
        "documentation": {}
    },
    {
        "label": "RETURN_TIME",
        "importPath": "src.const",
        "description": "src.const",
        "isExtraImport": true,
        "detail": "src.const",
        "documentation": {}
    },
    {
        "label": "ANTIVIRUS_LIST",
        "importPath": "src.const",
        "description": "src.const",
        "isExtraImport": true,
        "detail": "src.const",
        "documentation": {}
    },
    {
        "label": "WMI_NAMESPACE",
        "importPath": "src.const",
        "description": "src.const",
        "isExtraImport": true,
        "detail": "src.const",
        "documentation": {}
    },
    {
        "label": "WINDOWS_FIREWALL_PROFILES_RUS_ENG",
        "importPath": "src.const",
        "description": "src.const",
        "isExtraImport": true,
        "detail": "src.const",
        "documentation": {}
    },
    {
        "label": "VARIANTS",
        "importPath": "src.const",
        "description": "src.const",
        "isExtraImport": true,
        "detail": "src.const",
        "documentation": {}
    },
    {
        "label": "decision_handler",
        "importPath": "src.decision_handler",
        "description": "src.decision_handler",
        "isExtraImport": true,
        "detail": "src.decision_handler",
        "documentation": {}
    },
    {
        "label": "TestBasicConnection",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestBasicConnections (unittest.TestCase):\n  def test_basic_connection (self):\n    \"Check that a standard connection works\"\n    self.assert_ (wmi.WMI ())\n  def test_remote_connection (self):\n    \"Check that a remote connection works, if specified\"\n    if \"machine\" in settings:\n      self.assert_ (wmi.WMI (settings['machine']))\n    else:\n      warnings.warn (\"Skipping test_remote_connection\")",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestThreadedConnectio",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestThreadedConnection (unittest.TestCase):\n  def test_initialised_thread (self):\n    \"\"\"A WMI connection in a thread which has been initialised for COM\n    should succeed.\n    \"\"\"\n    def f (q):\n      pythoncom.CoInitialize ()\n      try:\n        try:\n          wmi.WMI ()",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMonike",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestMoniker (unittest.TestCase):\n  def test_moniker (self):\n    \"\"\"Look at all possible options for moniker construction and pass\n    them through to a WMI connector\n    \"\"\"\n    for computer in COMPUTERS:\n      if computer in (None, \".\"):\n        local_authorities = [None]\n      else:\n        local_authorities = AUTHORITIES",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestFunction",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestFunctions (unittest.TestCase):\n  times = [\n    ((2000, 1, 1), \"20000101******.******+***\"),\n    ((2000, 1, 1, 10, 0, 0), \"20000101100000.******+***\"),\n    ((2000, 1, 1, 10, 0, 0, 100), \"20000101100000.000100+***\"),\n    ((2000, 1, 1, 10, 0, 0, 100, \"GMT\"), \"20000101100000.000100+GMT\")\n  ]\n  def test_signed_to_unsigned (self):\n    tests = [\n      (0, 0),",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWM",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestWMI (unittest.TestCase):\n  def setUp (self):\n    self.connection = wmi.WMI (namespace=\"root/cimv2\", find_classes=False)\n    self.logical_disks = set (self.connection.Win32_LogicalDisk ())\nclass TestNamespace (TestWMI):\n  def test_subclasses_of_simple (self):\n    self.assert_ (\"Win32_ComputerSystem\" in self.connection.subclasses_of ())\n  def test_subclasses_of_subtree (self):\n    self.assert_ (\"Win32_Desktop\" in self.connection.subclasses_of (\"CIM_Setting\"))\n  def test_subclasses_of_pattern (self):",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestNamespac",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestNamespace (TestWMI):\n  def test_subclasses_of_simple (self):\n    self.assert_ (\"Win32_ComputerSystem\" in self.connection.subclasses_of ())\n  def test_subclasses_of_subtree (self):\n    self.assert_ (\"Win32_Desktop\" in self.connection.subclasses_of (\"CIM_Setting\"))\n  def test_subclasses_of_pattern (self):\n    self.assert_ (set ([\"Win32_LogicalDisk\", \"Win32_MappedLogicalDisk\"]) <= set (self.connection.subclasses_of (\"CIM_LogicalDevice\", \"Win32_.*Disk\")))\n  def test_instances (self):\n    self.assertEquals (self.logical_disks, set (self.connection.instances (\"Win32_LogicalDisk\")))\n  def test_new (self):",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestClas",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestClass (TestWMI):\n  def test_class_from_namespace (self):\n    self.assert_ (self.connection.Win32_ComputerSystem._namespace is self.connection)\n  def test_class_without_namespace (self):\n    wmi_class = wmi.GetObject (\"winmgmts:Win32_ComputerSystem\")\n    self.assert_ (wmi._wmi_class (None, wmi_class)._namespace)\n  def test_query (self):\n    self.assertEquals (\n      set (self.connection.Win32_ComputerSystem.query ()),\n      set (self.connection.query (\"SELECT * FROM Win32_ComputerSystem\"))",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestWatche",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestWatcher (TestWMI):\n  def new_letter (self):\n    return \\\n      set (\"%s:\" % chr (i) for i in range (ord ('A'), 1 + ord ('Z'))).\\\n      difference (d.DeviceID for d in self.connection.Win32_LogicalDisk ()).\\\n      pop ()\n  @staticmethod\n  def create (new_letter):\n    print \"about to create drive with letter\", new_letter\n    here = os.path.dirname (os.path.abspath (__file__))",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestMethod",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestMethods (TestWMI):\n  def test_exists (self):\n    \"Check that a well-known method is available by attribute\"\n    self.assert_ (self.connection.Win32_Process.Create)\n  def test_params (self):\n    \"Check that the names and arrayness of params are picked up when not arrays\"\n    self.assertEquals (\n      [(n, False) for n in [\"CommandLine\", \"CurrentDirectory\", \"ProcessStartupInformation\"]],\n      self.connection.Win32_Process.Create.in_parameter_names\n    )",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestPropertie",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestProperties (TestWMI):\n  def test_access (self):\n    \"Check that all properties are available as attributes\"\n    for d in self.logical_disks:\n      break\n    for p in d.ole_object.Properties_:\n      self.assertEqual (p.Value, getattr (d, p.Name))\n  def test_attribute_passthrough (self):\n    \"Check that unknown attributes are passed through to the underlying object\"\n    for d in self.logical_disks:",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstance",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestInstances (TestWMI):\n  def test_hashable (self):\n    \"Ensure instances are hashable so can be used in a set/dict\"\n    self.assert_ (dict.fromkeys (self.logical_disks))\n  def test_equalable (self):\n    \"Ensure instances compare equal\"\n    self.assertEqual (self.logical_disks, self.logical_disks)\n  def test_sortable (self):\n    \"Ensure instances sort by full path/key\"\n    self.assertEqual (",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestInstanceCreatio",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestInstanceCreation (TestWMI):\n  def test_create_instance (self):\n    self.assert_ (isinstance (self.connection.Win32_ProcessStartup.new (ShowWindow=2), wmi._wmi_object))\nclass TestAssociations (TestWMI):\n  def test_all_properties_available (self):\n    #\n    # An association can contain not only the associated\n    # classes but also extra information as well. Ensure\n    # that both types of data are correctly handled.\n    #",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "TestAssociation",
        "kind": 6,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "class TestAssociations (TestWMI):\n  def test_all_properties_available (self):\n    #\n    # An association can contain not only the associated\n    # classes but also extra information as well. Ensure\n    # that both types of data are correctly handled.\n    #\n    for q in self.connection.Win32_DiskQuota ():\n      for p in q.properties:\n        try:",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "ini",
        "kind": 5,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "ini = ConfigParser.SafeConfigParser ()\nini.read ([\"wmitest.master.ini\", \"wmitest.ini\"])\nsettings = {}\nif ini.has_section (\"settings\"):\n  settings.update (ini.items (\"settings\"))\nexcludes = [i.strip () for i in settings.get (\"excludes\", \"\").split (\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n  COMPUTERS.append (settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "settings",
        "kind": 5,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "settings = {}\nif ini.has_section (\"settings\"):\n  settings.update (ini.items (\"settings\"))\nexcludes = [i.strip () for i in settings.get (\"excludes\", \"\").split (\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n  COMPUTERS.append (settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "excludes",
        "kind": 5,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "excludes = [i.strip () for i in settings.get (\"excludes\", \"\").split (\",\")]\nCOMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n  COMPUTERS.append (settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set ([\"domain\", \"machine\"]) <= set (settings):\n  #~ AUTHORITIES.append (\"kerberos:%s\" % settings['domain'])\n  AUTHORITIES.append (\"ntlmdomain:%s\" % settings['domain'])",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "COMPUTERS",
        "kind": 5,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "COMPUTERS = [None, \".\"]\nif \"machine\" in settings:\n  COMPUTERS.append (settings['machine'])\nIMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set ([\"domain\", \"machine\"]) <= set (settings):\n  #~ AUTHORITIES.append (\"kerberos:%s\" % settings['domain'])\n  AUTHORITIES.append (\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "IMPERSONATION_LEVELS",
        "kind": 5,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "IMPERSONATION_LEVELS = [None, \"identify\", \"impersonate\", \"delegate\"]\nAUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set ([\"domain\", \"machine\"]) <= set (settings):\n  #~ AUTHORITIES.append (\"kerberos:%s\" % settings['domain'])\n  AUTHORITIES.append (\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections (unittest.TestCase):\n  def test_basic_connection (self):",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHENTICATION_LEVELS",
        "kind": 5,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "AUTHENTICATION_LEVELS = [None, \"default\", \"none\", \"connect\", \"call\", \"pkt\", \"pktintegrity\", \"pktprivacy\"]\nAUTHORITIES = [None]\nif set ([\"domain\", \"machine\"]) <= set (settings):\n  #~ AUTHORITIES.append (\"kerberos:%s\" % settings['domain'])\n  AUTHORITIES.append (\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections (unittest.TestCase):\n  def test_basic_connection (self):\n    \"Check that a standard connection works\"",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "AUTHORITIES",
        "kind": 5,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "AUTHORITIES = [None]\nif set ([\"domain\", \"machine\"]) <= set (settings):\n  #~ AUTHORITIES.append (\"kerberos:%s\" % settings['domain'])\n  AUTHORITIES.append (\"ntlmdomain:%s\" % settings['domain'])\nPRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections (unittest.TestCase):\n  def test_basic_connection (self):\n    \"Check that a standard connection works\"\n    self.assert_ (wmi.WMI ())",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "PRIVILEGES",
        "kind": 5,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "PRIVILEGES = [None, ['security', '!shutdown']]\nNAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections (unittest.TestCase):\n  def test_basic_connection (self):\n    \"Check that a standard connection works\"\n    self.assert_ (wmi.WMI ())\n  def test_remote_connection (self):\n    \"Check that a remote connection works, if specified\"\n    if \"machine\" in settings:\n      self.assert_ (wmi.WMI (settings['machine']))",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "NAMESPACES",
        "kind": 5,
        "importPath": ".venv.bin.wmitest",
        "description": ".venv.bin.wmitest",
        "peekOfCode": "NAMESPACES = [None, \"root/cimv2\", \"default\"]\nclass TestBasicConnections (unittest.TestCase):\n  def test_basic_connection (self):\n    \"Check that a standard connection works\"\n    self.assert_ (wmi.WMI ())\n  def test_remote_connection (self):\n    \"Check that a remote connection works, if specified\"\n    if \"machine\" in settings:\n      self.assert_ (wmi.WMI (settings['machine']))\n    else:",
        "detail": ".venv.bin.wmitest",
        "documentation": {}
    },
    {
        "label": "lin",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def link (text, computer, namespace=None, wmi_class=None):\n  link = '<a href=\"/' + quote (computer)\n  if namespace:\n    link += \"/\" + quote (namespace)\n  if wmi_class:\n    link += \"/\" + quote (wmi_class)\n  return link + '\">' + escape (text) + '</a>'\ndef start_doc (title):\n  doc[:] = []\n  doc.append (\"\"\"",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "start_do",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def start_doc (title):\n  doc[:] = []\n  doc.append (\"\"\"\n  <html>\n  <head>\n  <title>%(title)s</title>\n  <style>\n  body {font-family : Verdana, sans-serif; font-size : 84%%; margin : 3em;}\n  table.items {padding-left : 30px;}\n  li, td {font-family : \"Courier New\", monospace;}",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "finish_do",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def finish_doc ():\n  doc.append (\"\"\"\n  </body>\n  </html>\n  \"\"\" % locals ())\ndef doc_table (items, n_cols=3):\n  n_rows, n_spare_cols = divmod (len (items), n_cols)\n  doc.append ('<table cellspacing=0 class=\"items\">')\n  for n_row in range (n_rows):\n    doc.append (\"<tr>\")",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_tabl",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def doc_table (items, n_cols=3):\n  n_rows, n_spare_cols = divmod (len (items), n_cols)\n  doc.append ('<table cellspacing=0 class=\"items\">')\n  for n_row in range (n_rows):\n    doc.append (\"<tr>\")\n    for n_col in range (n_cols):\n      doc.append (\"<td><li>%s</li></td>\" % items[n_cols * n_col + n_row])\n    doc.append (\"</tr>\")\n  if n_spare_cols:\n    doc.append (\"<tr>\")",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_breadcrumb",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def doc_breadcrumbs (computer, namespace, wmi_class=None):\n  doc.append ('<p class=\"breadcrumbs\">')\n  doc.append ('%s &rarr; %s' % (link (computer, computer), link (namespace, computer, namespace)))\n  if wmi_class:\n    doc.append (' &rarr; %s' % (link (wmi_class, computer, namespace, wmi_class)))\n  doc.append ('</p>')\ndef doc_wmi_class (computer, namespace, wmi_class, wmi_connection):\n  start_doc (\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals ())\n  doc_breadcrumbs (computer, namespace, wmi_class)\n  doc.append (\"<h2>%(wmi_class)s</h2>\" % locals ())",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_wmi_clas",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def doc_wmi_class (computer, namespace, wmi_class, wmi_connection):\n  start_doc (\"WMI: Class %(wmi_class)s in namespace %(namespace)s on %(computer)s\" % locals ())\n  doc_breadcrumbs (computer, namespace, wmi_class)\n  doc.append (\"<h2>%(wmi_class)s</h2>\" % locals ())\n  klass = getattr (wmi_connection, wmi_class)\n  doc.append (\"<hr>\")\n  doc.append (\"<h3>Ancestors</h3>\")\n  ancestors = klass.derivation ()\n  if ancestors:\n    doc.append (\" <b>:</b> \".join (link (ancestor, computer, namespace, ancestor) for ancestor in reversed (ancestors)))",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc_namespac",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def doc_namespace (computer, namespace, wmi_connection):\n  start_doc (\"WMI: Namespace %(namespace)s on %(computer)s\" % locals ())\n  doc_breadcrumbs (computer, namespace)\n  namespaces = namespace.split (\"\\\\\")\n  namespace_links = []\n  for i, n in enumerate (namespaces):\n    namespace_links.append (link (n, computer, \"\\\\\".join (namespaces[:i+1])))\n  doc.append (\"<h2>%s</h2>\" % \"\\\\\".join (namespace_links))\n  doc.append (\"<hr>\")\n  subnamespaces = sorted (wmi_connection.__NAMESPACE ())",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_namespac",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def handle_namespace (environ, computer, namespace):\n  if not namespace:\n    wmi_connection = wmi.WMI (computer, namespace=\"root/cimv2\")\n    for setting in wmi_connection.Win32_WMISetting ():\n      namespace=setting.ASPScriptDefaultNamespace\n      break\n  wmi_connection = wmi.WMI (computer, namespace=namespace, find_classes=True)\n  wmi_class = shift_path_info (environ)\n  if wmi_class:\n    doc_wmi_class (computer, namespace, wmi_class, wmi_connection)",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "handle_compute",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def handle_computer (environ, computer):\n  handle_namespace (environ, computer, shift_path_info (environ))\ndef app (environ, start_response):\n  computer = shift_path_info (environ)\n  if computer == \"favicon.ico\":\n    start_response (\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n    return []\n  elif computer:\n    start_response (\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n    handle_computer (environ, computer)",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "ap",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def app (environ, start_response):\n  computer = shift_path_info (environ)\n  if computer == \"favicon.ico\":\n    start_response (\"404 Not Found\", [(\"Content-Type\", \"text/plain\")])\n    return []\n  elif computer:\n    start_response (\"200 OK\", [(\"Content-Type\", \"text/html; charset=utf-8\")])\n    handle_computer (environ, computer)\n    return (unicode (d).encode (\"utf8\") + unicode (\"\\n\").encode (\"utf8\") for d in doc)\n  else:",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "run_browse",
        "kind": 2,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "def run_browser ():\n  import os\n  os.startfile (\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n  threading.Timer (3.0, run_browser).start ()\n  httpd = make_server ('', PORT, app)\n  try:\n    httpd.serve_forever ()\n  except KeyboardInterrupt:\n    print (\"Shutting down gracefully...\")",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "doc",
        "kind": 5,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "doc = []\ndef link (text, computer, namespace=None, wmi_class=None):\n  link = '<a href=\"/' + quote (computer)\n  if namespace:\n    link += \"/\" + quote (namespace)\n  if wmi_class:\n    link += \"/\" + quote (wmi_class)\n  return link + '\">' + escape (text) + '</a>'\ndef start_doc (title):\n  doc[:] = []",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "PORT",
        "kind": 5,
        "importPath": ".venv.bin.wmiweb",
        "description": ".venv.bin.wmiweb",
        "peekOfCode": "PORT = 8010\ndef run_browser ():\n  import os\n  os.startfile (\"http://localhost:%d\" % PORT)\nif __name__ == '__main__':\n  threading.Timer (3.0, run_browser).start ()\n  httpd = make_server ('', PORT, app)\n  try:\n    httpd.serve_forever ()\n  except KeyboardInterrupt:",
        "detail": ".venv.bin.wmiweb",
        "documentation": {}
    },
    {
        "label": "app_cli",
        "kind": 2,
        "importPath": "src.cli",
        "description": "src.cli",
        "peekOfCode": "def app_cli():\n    print(\"1 --- Проверка наличия подключения к интернету\")\n    print(\"2 --- Проверка наличия установленного межсетвоего экрана\")\n    print(\"3 --- Проверка работоспособности межсетевого экрана\")\n    print(\"4 --- Проверка наличия установленного антивирусного ПО\")\n    print(\"5 --- Проверка наличия работоспособности антивирусного ПО\")\n    print(\"0 --- Выход из программы\")",
        "detail": "src.cli",
        "documentation": {}
    },
    {
        "label": "decision_handler",
        "kind": 2,
        "importPath": "src.decision_handler",
        "description": "src.decision_handler",
        "peekOfCode": "def decision_handler(variant: int) -> None:\n    if not variant_validate:\n        invalid_variant_handler()\n        return\n    match variant:\n        case 0:\n            exit(0)\n        case 1:\n            check_internet_connection()\n            app_cli()",
        "detail": "src.decision_handler",
        "documentation": {}
    },
    {
        "label": "check_internet_connection",
        "kind": 2,
        "importPath": "src.funcs",
        "description": "src.funcs",
        "peekOfCode": "def check_internet_connection() -> None:\n    conn_data = (GOOGLE_SERVER_ADDRESS, PORT)\n    try:\n        socket.create_connection(conn_data, timeout=3)\n        print(\"Подлючение к интернету установлено\")\n    except OSError: ## Ошибки, связанные с веб-взаимодействием\n        print(\"Подключение к интернету отсутствует\")\n    finally:\n        time.sleep(RETURN_TIME)\n    return",
        "detail": "src.funcs",
        "documentation": {}
    },
    {
        "label": "check_installed_antivirus",
        "kind": 2,
        "importPath": "src.funcs",
        "description": "src.funcs",
        "peekOfCode": "def check_installed_antivirus() -> None:\n    ## Случай 1. Антивирус -- активный процесс\n    for process in psutil.process_iter([\"name\"]):\n        name = process.info[\"name\"].lower()\n        if any(av_process_name_part in name for av_process_name_part in ANTIVIRUS_LIST):\n            print(f\"Антивирус {process.info[\"name\"]} установлен и находится во включенном состоянии\")\n            time.sleep(RETURN_TIME)\n            return\n    ## Случай 2. Антивирус не включён. Проверка на нахождение в системе\n    if platform.system() == \"Windows\":",
        "detail": "src.funcs",
        "documentation": {}
    },
    {
        "label": "check_installed_firewall",
        "kind": 2,
        "importPath": "src.funcs",
        "description": "src.funcs",
        "peekOfCode": "def check_installed_firewall() -> None:\n    if platform.system() == \"Windows\":\n        try:\n            res = subprocess.run(\n                [\"netsh\", \"advfirewall\", \"show\", \"allprofiles\"],\n                capture_output=True,\n                text=True\n            )\n            output = res.stdout.lower()\n            if any(profile in output for profile in WINDOWS_FIREWALL_PROFILES_RUS_ENG):",
        "detail": "src.funcs",
        "documentation": {}
    },
    {
        "label": "variant_validate",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def variant_validate(variant) -> bool:\n    return isinstance(variant, int) and variant in VARIANTS\ndef invalid_variant_handler():\n    print(\"Выбранной опции не существует\")\n    try:\n        is_exit = int(input(\"Хотите выйти? Введите 0 или 1 (0 - Нет, 1 - да)\"))\n        if is_exit:\n            exit()\n        else:\n            app_cli()",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "invalid_variant_handler",
        "kind": 2,
        "importPath": "src.utils",
        "description": "src.utils",
        "peekOfCode": "def invalid_variant_handler():\n    print(\"Выбранной опции не существует\")\n    try:\n        is_exit = int(input(\"Хотите выйти? Введите 0 или 1 (0 - Нет, 1 - да)\"))\n        if is_exit:\n            exit()\n        else:\n            app_cli()\n    except TypeError:\n        invalid_variant_handler()",
        "detail": "src.utils",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "main",
        "description": "main",
        "peekOfCode": "def main():\n    app_cli()\n    variant = input(\"Введите опцию из списка: \")\n    decision_handler(variant)\nif __name__ == \"__main__\":\n    main()",
        "detail": "main",
        "documentation": {}
    }
]